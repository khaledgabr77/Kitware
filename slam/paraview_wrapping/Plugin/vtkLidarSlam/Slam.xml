<ServerManagerConfiguration>

  <!-- Begin Online Slam -->
  <ProxyGroup name="filters">
    <SourceProxy name="SlamOnline"
                 class="vtkSlam"
                 label="SLAM (online)">

      <Documentation
        short_help="Performs real-time SLAM on the Lidar sensor's pointclouds."
        long_help="Performs real-time SLAM on the Lidar sensor's pointclouds.">
        The SLAM filter uses LiDAR sensor pointclouds to compute sensor's
        trajectory and build a map of the environment.

        The SLAM algorithm is composed of four sequential steps:

          - Sampling strategy: extract keypoints that provide strong geometric information

          - Ego-Motion: estimate sensor motion since last frame

          - Localization: compute current frame pose in map using estimated Ego-Motion

          - Map update : add current registered points in map

        This filter performs real-time processing of input frames (it may skip
        some frames if too slow) with live display.
      </Documentation>

      <InputProperty name="Input"
                     command="SetInputConnection"
                     label="Point Cloud"
                     port_index="0">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain composite_data_supported="1"
                        name="input_type">
          <DataType value="vtkPolyData"/>
        </DataTypeDomain>
        <Documentation>
          Set the input port to use where LiDAR point clouds are broadcasted.
        </Documentation>
      </InputProperty>

      <InputProperty name="Calibration"
                     command="SetInputConnection"
                     port_index="1"
                     null_on_empty="1">
        <Hints>
          <Optional /> <!-- No input selection dialog at instantiation -->
        </Hints>
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkTable"/>
        </DataTypeDomain>
        <Documentation>
          Optional LiDAR sensor calibration to use to correct laser rings' IDs.
        </Documentation>
      </InputProperty>

      <OutputPort name="Current transformed frame" index="0" id="port0" />
      <OutputPort name="Trajectory"                index="1" id="port1" />
      <OutputPort name="Edge map"                  index="2" id="port2" />
      <OutputPort name="Planar map"                index="3" id="port3" />
      <OutputPort name="Blob map"                  index="4" id="port4" />
      <OutputPort name="Current edge keypoints"    index="5" id="port5" />
      <OutputPort name="Current planar keypoints"  index="6" id="port6" />
      <OutputPort name="Current blob keypoints"    index="7" id="port7" />

      <!-- ============= Paraview filter inputs/outputs options ============ -->

      <Property name="Reset state"
                command="Reset">
        <Documentation>
          Reset SLAM internal state : maps and trajectory are cleared, and
          current pose is set back to origin.
          This keeps parameters and sensor data unchanged.
        </Documentation>
      </Property>

      <!--~~~~~~~~~~~~~~~~~~~~~~~~~ Inputs options ~~~~~~~~~~~~~~~~~~~~~~~~~~-->

      <!-- Sensor data file must be csv.
           A field time in POSIX format is necessary
           Possible sensor fields are : odom, [acc_x, acc_y, acc_z].
           This file is loaded in PV wrapping.
           It is used to add constraints to the SLAM optimization -->
      <StringVectorProperty name="SensorDataFile"
                            command="SetSensorData"
                            number_of_elements="1"
                            animateable="0"
                            panel_visibility="advanced">
        <FileListDomain name="files"/>
        <Documentation>
          The path of the external sensor data file to use.

          This CSV file can have the following columns:

          *time*: Posix time, in seconds

          *odom*: Wheel odometry, in meters

          *acc_x/acc_y/acc_z*: Acceleration from IMU, in meters/second
        </Documentation>
      </StringVectorProperty>

      <IntVectorProperty name="Auto detect input arrays"
                         command="SetAutoDetectInputArrays"
                         number_of_elements="1"
                         default_values="1"
                         panel_visibility="advanced">
        <BooleanDomain name="bool" />
        <Documentation>
          If enabled, SLAM filter will try to auto-detect the time, intensity
          and laser ring id arrays to use depending on LiDAR model.
        </Documentation>
      </IntVectorProperty>

      <!-- If auto-detection mode is disabled, user needs to specify input arrays to use -->
      <StringVectorProperty name="Time array"
                            command="SetInputArrayToProcess"
                            number_of_elements="5"
                            element_types="0 0 0 0 2"
                            default_values="0"
                            panel_visibility="advanced">
        <ArrayListDomain attribute_type="Scalars" name="array_list">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>
          The points measurements timestamps.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" property="Auto detect input arrays" value="0" />
        </Hints>
      </StringVectorProperty>

      <StringVectorProperty name="Intensity array"
                            command="SetInputArrayToProcess"
                            number_of_elements="5"
                            element_types="0 0 0 0 2"
                            default_values="1"
                            panel_visibility="advanced">
        <ArrayListDomain attribute_type="Scalars" name="array_list">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>
          The points intensity/reflectivity measurements.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" property="Auto detect input arrays" value="0" />
        </Hints>
      </StringVectorProperty>

      <StringVectorProperty name="Laser ring id array"
                            command="SetInputArrayToProcess"
                            number_of_elements="5"
                            element_types="0 0 0 0 2"
                            default_values="2"
                            panel_visibility="advanced">
        <ArrayListDomain attribute_type="Scalars" name="array_list">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>
          The laser ring ids that acquired points.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" property="Auto detect input arrays" value="0" />
        </Hints>
      </StringVectorProperty>

      <StringVectorProperty name="Elevation angles calibration"
                            command="SetInputArrayToProcess"
                            number_of_elements="5"
                            element_types="0 0 0 0 2"
                            default_values="3"
                            panel_visibility="advanced">
        <ArrayListDomain attribute_type="Scalars" name="array_list">
          <RequiredProperties>
            <Property function="Input" name="Calibration" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>
          Calibration column used to sort laser rings by ascending elevation angle
          (the lowest/bottom laser ring should be 0, and it should increase upward).
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" property="Auto detect input arrays" value="0" />
        </Hints>
      </StringVectorProperty>

      <DoubleVectorProperty name="Time to seconds factor"
                            command="SetTimeToSecondsFactorSetting"
                            number_of_elements="1"
                            default_values="1e-6"
                            panel_visibility="advanced">
        <Documentation>
          Coefficient to apply to *Time array* values to express timestamps in seconds.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" property="Auto detect input arrays" value="0" />
        </Hints>
      </DoubleVectorProperty>

      <!--~~~~~~~~~~~~~~~~~~~~~~~~~ Outputs options ~~~~~~~~~~~~~~~~~~~~~~~~~-->

      <IntVectorProperty name="Advanced return mode"
                         command="SetAdvancedReturnMode"
                         number_of_elements="1"
                         default_values="0">
        <BooleanDomain name="bool" />
        <Documentation>
          If advanced return mode is enabled, extra arrays are added to the
          outputs to display some of the SLAM internal variables :

           - Trajectory : matching summary, localization error summary, confidence estimators

           - Output transformed frame : saliency, planarity, intensity gap, keypoint validity

           - Extracted keypoints : ICP matching results

          It is very useful when debugging or checking the SLAM behavior.
          If disabled, the overlap estimation is not computed.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="Output keypoints maps"
                         command="SetOutputKeypointsMaps"
                         number_of_elements="1"
                         default_values="1">
        <BooleanDomain name="bool" />
        <Documentation>
          If enabled, SLAM filter will output keypoints maps.
          Otherwise, these filter outputs are left empty to save time.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="Keypoints maps update step"
                         command="SetMapsUpdateStep"
                         number_of_elements="1"
                         default_values="1"
                         panel_visibility="advanced">
        <Documentation>
          SLAM filter will update keypoints maps only 1 frame over *step* to save time.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator" mode="enabled_state" property="Output keypoints maps" value="1" />
        </Hints>
      </IntVectorProperty>

      <IntVectorProperty name="Output current keypoints"
                         command="SetOutputCurrentKeypoints"
                         number_of_elements="1"
                         default_values="1">
        <BooleanDomain name="bool" />
        <Documentation>
          If enabled, SLAM filter will output keypoints extracted from current
          frame. Otherwise, these filter outputs are left empty to save time.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="Output keypoints in WORLD coordinates"
                         command="SetOutputKeypointsInWorldCoordinates"
                         number_of_elements="1"
                         default_values="1"
                         panel_visibility="advanced">
        <BooleanDomain name="bool" />
        <Documentation>
          If disabled, return raw keypoints extracted from current frame in BASE
          coordinates, without undistortion.

          If enabled, return keypoints in WORLD coordinates, optionally
          undistorted if undistortion is activated.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator" mode="enabled_state" property="Output current keypoints" value="1" />
        </Hints>
      </IntVectorProperty>

      <PropertyGroup label="Filter inputs/outputs options">
        <Property name="Reset state" />
        <Property name="SensorDataFile" />
        <Property name="Auto detect input arrays" />
        <Property name="Time array" />
        <Property name="Intensity array" />
        <Property name="Laser ring id array" />
        <Property name="Elevation angles calibration" />
        <Property name="Time to seconds factor" />
        <Property name="Advanced return mode" />
        <Property name="Output keypoints maps" />
        <Property name="Keypoints maps update step" />
        <Property name="Output current keypoints" />
        <Property name="Output keypoints in WORLD coordinates" />
      </PropertyGroup>

      <!-- ============================ General ============================ -->

      <IntVectorProperty name="2d mode"
                         command="SetTwoDMode"
                         number_of_elements="1"
                         default_values="0">
        <BooleanDomain name="bool" />
        <Documentation>
          Optimize only 2D pose in BASE coordinates.
          Only X, Y (ground coordinates) and yaw (rZ) will be optimized,
          whereas Z (elevation), rX (roll) and rY (pitch) will be held constant.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="Use blobs"
                         command="SetUseBlobs"
                         number_of_elements="1"
                         default_values="0" >
        <BooleanDomain name="bool" />
        <Documentation>
          If enabled, blob keypoints are used in localization step.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="Verbosity level"
                         command="SetVerbosity"
                         number_of_elements="1"
                         default_values="0" >
        <EnumerationDomain name="enum">
          <Entry value="0" text="0) Errors, warnings or one time info"/>
          <Entry value="1" text="1) 0 + Frame total processing duration"/>
          <Entry value="2" text="2) 1 + Main steps summary"/>
          <Entry value="3" text="3) 2 + Sub-problems processing duration"/>
          <Entry value="4" text="4) 3 + Ceres optimization summary"/>
          <Entry value="5" text="5) 4 + Logging/maps memory usage"/>
        </EnumerationDomain>
        <Documentation>
          Indicate verbosity level to display more or less information in console:

           (0) print errors, warnings or one time info;

           (1) 0 + frame number and total processing duration;

           (2) 1 + extracted features, used keypoints, localization variance, ego-motion and localization summary;

           (3) 2 + sub-problems processing duration;

           (4) 3 + ceres optimization summary;

           (5) 4 + logging/maps memory usage.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="Ego-Motion mode"
                         command="SetEgoMotion"
                         number_of_elements="1"
                         default_values="1">
        <EnumerationDomain name="enum">
          <Entry value="0" text="Disabled"/>
          <Entry value="1" text="Motion extrapolation"/>
          <Entry value="2" text="Registration on previous frame"/>
          <Entry value="3" text="Motion extrapolation + Registration"/>
        </EnumerationDomain>
        <Documentation>
          How to estimate Ego-Motion (approximate relative motion since last frame).
          The ego-motion step aims to give a fast and approximate initialization of new
          frame world pose to ensure faster and more precise convergence in Localization step.

          If DISABLED, no ego-motion step is performed : relative motion is Identity, new estimated
          Tworld is equal to previous Tworld. Fast, but may lead to unstable and imprecise
          Localization step if motion is important.

          If MOTION EXTRAPOLATION, previous motion is linearly extrapolated to estimate new Tworld pose
          from the 2 previous poses. Fast and precise if motion is roughly constant and continuous.

          If REGISTRATION ON PREVIOUS FRAME, Trelative (and therefore Tworld) is estimated by globally
          registering new frame on previous frame. Slower and need textured enough environment, but do not
          rely on constant motion hypothesis.

          If MOTION EXTRAPOLATION + REGISTRATION ON PREVIOUS FRAME, previous motion is linearly extrapolated
          to estimate new Tworld pose from the 2 previous poses. Then this estimation is refined by globally
          registering new frame on previous frame. Slower and need textured enough environment, but should
          be more precise and rely less on constant motion hypothesis.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="Undistortion mode"
                         command="SetUndistortion"
                         number_of_elements="1"
                         default_values="2">
        <EnumerationDomain name="enum">
          <Entry value="0" text="Disabled"/>
          <Entry value="1" text="Once"/>
          <Entry value="2" text="Refined"/>
        </EnumerationDomain>
        <Documentation>
          Undistortion mode, to correct rolling shutter distortion during frame acquisition.
          The undistortion should greatly improve the accuracy for smooth motions,
          but might be unstable for high-frequency motions.

          DISABLED: no undistortion is performed.

          ONCE: undistortion is performed only once using estimated ego-motion.

          REFINED: undistortion is iteratively refined using optimized ego-motion.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="Number of threads"
                         command="SetNbThreads"
                         number_of_elements="1"
                         default_values="1">
        <IntRangeDomain name="range" min="1" max="16"/>
        <Documentation>
          Max number of threads to use for parallel processing.
        </Documentation>
      </IntVectorProperty>

      <PropertyGroup label="General Parameters">
        <Property name="2d mode" />
        <Property name="Use blobs" />
        <Property name="Verbosity level" />
        <Property name="Ego-Motion mode" />
        <Property name="Undistortion mode" />
        <Property name="Number of threads" />
      </PropertyGroup>

      <!-- ============================ Initialization ============================ -->
      <!-- Path prefix of SLAM maps (if empty, no map is loaded).
           The files must be pcd.
           The new maps replace the previous computed ones-->
      <StringVectorProperty name="Initial map files prefix"
                            command="SetInitialMap"
                            number_of_elements="1"
                            animateable="0"
                            panel_visibility="advanced">
        <FileListDomain name="files"/>
        <Hints>
          <FileChooser extensions="pcd" file_description="pcd file format" />
        </Hints>
        <Documentation>
          The path prefix of the initial map files.

          3 maps will be searched and loaded if found:
              path/to/maps/prefix*edges.pcd*
              path/to/maps/prefix*planes.pcd*
              path/to/maps/prefix*blobs.pcd*
        </Documentation>
      </StringVectorProperty>

      <!-- Reset the pose of the SLAM
           Warning: a click on the Reset button applies this pose again-->
      <DoubleVectorProperty name="Initial pose XYZ"
                            command="SetInitialPoseTranslation"
                            number_of_elements="3"
                            default_values="0. 0. 0."
                            panel_visibility="advanced">
        <Documentation>
          Translation elements of the initial SLAM pose in format X, Y, Z
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Initial pose RPY"
                            command="SetInitialPoseRotation"
                            number_of_elements="3"
                            default_values="0. 0. 0."
                            panel_visibility="advanced">
        <Documentation>
          Rotation elements of the initial SLAM pose in format Roll, Pitch, Yaw
        </Documentation>
      </DoubleVectorProperty>

      <PropertyGroup label="SLAM initialization">
        <Property name="Initial map files prefix" />
        <Property name="Initial pose XYZ" />
        <Property name="Initial pose RPY" />
      </PropertyGroup>

      <!-- ================ Keypoints extraction Parameters ================ -->

      <ProxyProperty name="KeyPointsExtractor"
                     command="SetKeyPointsExtractor"
                     label="Keypoints extractor">
        <ProxyListDomain name="proxy_list">
          <Group name="KeyPointsExtractors"/>
        </ProxyListDomain>
        <Documentation>
          The keypoints extractor to use to get keypoints from raw input frame.
        </Documentation>
      </ProxyProperty>

      <!-- ==================== BASE to LIDAR transform ==================== -->

      <DoubleVectorProperty name="Translation"
                            command="SetBaseToLidarTranslation"
                            number_of_elements="3"
                            default_values="0. 0. 0."
                            panel_visibility="advanced">
        <Documentation>
          Position of the LiDAR sensor in BASE coordinate system (X, Y, Z).

          It is often useful to track a BASE pose instead of LiDAR sensor pose.
          If set, this parameter transform all input pointcloud into BASE coordinate
          system in order to output BASE trajectory.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Rotation"
                            command="SetBaseToLidarRotation"
                            number_of_elements="3"
                            default_values="0. 0. 0."
                            panel_visibility="advanced">
        <Documentation>
          Rotation of the LiDAR sensor in BASE coordinate system (rX, rY, rZ, euler angles in ZYX convention, in degrees).

          It is often useful to track a BASE pose instead of LiDAR sensor pose.
          If set, this parameter transform all input pointcloud into BASE coordinate
          system in order to output BASE trajectory.
        </Documentation>
      </DoubleVectorProperty>

      <PropertyGroup label="Base to LiDAR transform">
        <Property name="Translation" />
        <Property name="Rotation" />
      </PropertyGroup>

      <!-- ===================== Ego Motion Parameters ===================== -->

      <IntVectorProperty name="ICP-Optimization iterations EM"
                         command="SetEgoMotionICPMaxIter"
                         number_of_elements="1"
                         default_values="4"
                         panel_visibility="advanced">
        <Documentation>
          The registration of the current frame on the previous frame is performed
          iteratively, building point-to-model Mahalanobis distance functions
          during an ICP step, followed by a non-linear optimization of these residuals.

          This parameter is the number of ICP-optimization iterations to perform.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="LM optimization iterations EM"
                         command="SetEgoMotionLMMaxIter"
                         number_of_elements="1"
                         default_values="15"
                         panel_visibility="advanced">
        <Documentation>
          Max number of iterations of the Levenberg-Marquardt optimizer to solve
          the ICP problem
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty name="Max neighbors distance EM"
                            command="SetEgoMotionMaxNeighborsDistance"
                            number_of_elements="1"
                            default_values="5."
                            panel_visibility="advanced">
        <Documentation>
          Max distance allowed between a keypoint and its neighbors from the
          previous frame to build an ICP match
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty name="Edge nb of neighbors EM"
                         command="SetEgoMotionEdgeNbNeighbors"
                         number_of_elements="1"
                         default_values="8"
                         panel_visibility="advanced">
        <Documentation>
          Initial number of edge neighbors to extract, that will be filtered out
          to keep best candidates.

          At least 2 points are needed to build a valid line model.
          If below, line models won't be usable and will be ignored.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="Edge nb min filtered neighbors EM"
                         command="SetEgoMotionEdgeMinNbNeighbors"
                         number_of_elements="1"
                         default_values="3"
                         panel_visibility="advanced">
        <Documentation>
          Min number of resulting filtered edge neighbors (max 1 per scan line)
          to approximate the corresponding line model.

          At least 2 points are needed to build a valid line model.
          If below, line models won't be usable and will be ignored.
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty name="Edge PCA factor EM"
                            command="SetEgoMotionEdgePcaFactor"
                            number_of_elements="1"
                            default_values="5."
                            panel_visibility="advanced">
        <Documentation>
          To check the line neighborhood shape, the PCA eigenvalues must respect:

          *EigenValue2 >= Factor x EigenValue1*

          with *EigenValue2 >= EigenValue1 >= EigenValue0*
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Edge max model error EM"
                            command="SetEgoMotionEdgeMaxModelError"
                            number_of_elements="1"
                            default_values="0.2"
                            panel_visibility="advanced">
        <Documentation>
          Max RMSE allowed between neighborhood and its fitted line model to
          keep only accurate models
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty name="Plane nb of neighbors EM"
                         command="SetEgoMotionPlaneNbNeighbors"
                         number_of_elements="1"
                         default_values="5"
                         panel_visibility="advanced">
        <Documentation>
          Number of plane neighbors to extract to approximate the corresponding
          plane model.

          At least 3 points are needed to build a valid plane model.
          If below, plane models won't be usable and will be ignored.
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty name="Plane PCA factor 1 EM"
                            command="SetEgoMotionPlanePcaFactor1"
                            number_of_elements="1"
                            default_values="35."
                            panel_visibility="advanced">
        <Documentation>
          To check the plane neighborhood shape, the PCA eigenvalues must respect:

          *EigenValue1 >= Factor1 x EigenValue0*

          *Factor2 x EigenValue1 >= EigenValue2*

          with *EigenValue2 >= EigenValue1 >= EigenValue0*
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Plane PCA factor 2 EM"
                            command="SetEgoMotionPlanePcaFactor2"
                            number_of_elements="1"
                            default_values="8."
                            panel_visibility="advanced">
        <Documentation>
          To check the plane neighborhood shape, the PCA eigenvalues must respect:

          *EigenValue1 >= Factor1 x EigenValue0*

          *Factor2 x EigenValue1 >= EigenValue2*

          with *EigenValue2 >= EigenValue1 >= EigenValue0*
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Plane max model error EM"
                            command="SetEgoMotionPlaneMaxModelError"
                            number_of_elements="1"
                            default_values="0.2"
                            panel_visibility="advanced">
        <Documentation>
          Max RMSE allowed between neighborhood and its fitted plane model to
          keep only accurate models
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Init saturation distance EM"
                            command="SetEgoMotionInitSaturationDistance"
                            number_of_elements="1"
                            default_values="5."
                            panel_visibility="advanced">
        <Documentation>
          Maximum distance (in meters) beyond which the residual errors are
          saturated to robustify the optimization against outlier constraints.
          The residuals will be robustified by Tukey loss (50% of saturation at
          *SaturationDistance/2*, fully saturated at *SaturationDistance*).

          The saturation distance at each iteration is linearly interpolated
          between *Init* and *Final* saturation distance parameters.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Final saturation distance EM"
                            command="SetEgoMotionFinalSaturationDistance"
                            number_of_elements="1"
                            default_values="1."
                            panel_visibility="advanced">
        <Documentation>
          Maximum distance (in meters) beyond which the residual errors are
          saturated to robustify the optimization against outlier constraints.
          The residuals will be robustified by Tukey loss (50% of saturation at
          *SaturationDistance/2*, fully saturated at *SaturationDistance*).

          The saturation distance at each iteration is linearly interpolated
          between *Init* and *Final* saturation distance parameters.
        </Documentation>
      </DoubleVectorProperty>

      <PropertyGroup label="Ego-Motion registration ICP matching and optimization parameters">
        <Property name="ICP-Optimization iterations EM" />
        <Property name="LM optimization iterations EM" />
        <Property name="Max neighbors distance EM" />
        <Property name="Edge nb of neighbors EM" />
        <Property name="Edge nb min filtered neighbors EM" />
        <Property name="Edge PCA factor EM" />
        <Property name="Edge max model error EM" />
        <Property name="Plane nb of neighbors EM" />
        <Property name="Plane PCA factor 1 EM" />
        <Property name="Plane PCA factor 2 EM" />
        <Property name="Plane max model error EM" />
        <Property name="Init saturation distance EM" />
        <Property name="Final saturation distance EM" />
        <Hints>
          <!-- Show these parameters only if Ego-motion registration is enabled (Paraview >5.6)-->
          <PropertyWidgetDecorator type="CompositeDecorator">
            <Expression type="or">
              <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" property="Ego-Motion mode" value="2" />
              <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" property="Ego-Motion mode" value="3" />
            </Expression>
          </PropertyWidgetDecorator>
        </Hints>
      </PropertyGroup>

      <!-- ==================== Localization Parameters ==================== -->

      <DoubleVectorProperty name="Wheel odometry weight"
                            command="SetWheelOdomWeight"
                            number_of_elements="1"
                            default_values="0."
                            panel_visibility="advanced">
        <Documentation>
          Wheel odometry weight.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" inverse="1" property="SensorDataFile" value="" />
        </Hints>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="IMU gravity weight"
                            command="SetGravityWeight"
                            number_of_elements="1"
                            default_values="0."
                            panel_visibility="advanced">
        <Documentation>
          IMU gravity alignment weight.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" inverse="1" property="SensorDataFile" value="" />
        </Hints>
      </DoubleVectorProperty>

      <IntVectorProperty name="ICP-Optimization iterations"
                         command="SetLocalizationICPMaxIter"
                         number_of_elements="1"
                         default_values="3"
                         panel_visibility="advanced">
        <Documentation>
          The registration of the current frame on the map is performed iteratively,
          building point-to-model Mahalanobis distance functions during an ICP step,
          followed by a non-linear optimization of these residuals.

          This parameter is the number of ICP-optimization iterations to perform.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="LM optimization iterations"
                         command="SetLocalizationLMMaxIter"
                         number_of_elements="1"
                         default_values="15"
                         panel_visibility="advanced">
        <Documentation>
          Max number of iterations of the Levenberg-Marquardt optimizer to solve
          the ICP problem
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty name="Max neighbors distance"
                            command="SetLocalizationMaxNeighborsDistance"
                            number_of_elements="1"
                            default_values="5."
                            panel_visibility="advanced">
        <Documentation>
          Max distance allowed between a keypoint and its neighbors from the map
          to build an ICP match
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty name="Edge nb of neighbors"
                         command="SetLocalizationEdgeNbNeighbors"
                         number_of_elements="1"
                         default_values="10"
                         panel_visibility="advanced">
        <Documentation>
          Initial number of edge neighbors to extract, that will be filtered out
          to keep best candidates.

          At least 2 points are needed to build a valid line model.
          If below, line models won't be usable and will be ignored.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="Edge nb min filtered neighbors"
                         command="SetLocalizationEdgeMinNbNeighbors"
                         number_of_elements="1"
                         default_values="4"
                         panel_visibility="advanced">
        <Documentation>
          Min number of resulting filtered edge neighbors (close to best line
          candidate) to approximate the corresponding line model.

          At least 2 points are needed to build a valid line model.
          If below, line models won't be usable and will be ignored.
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty name="Edge PCA factor"
                            command="SetLocalizationEdgePcaFactor"
                            number_of_elements="1"
                            default_values="5."
                            panel_visibility="advanced">
        <Documentation>
          To check the line neighborhood shape, the PCA eigenvalues must respect:

          *EigenValue2 >= Factor x EigenValue1*

          with *EigenValue2 >= EigenValue1 >= EigenValue0*
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Edge max model error"
                            command="SetLocalizationEdgeMaxModelError"
                            number_of_elements="1"
                            default_values="0.2"
                            panel_visibility="advanced">
        <Documentation>
          Max RMSE allowed between neighborhood and its fitted line model to
          keep only accurate models
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty name="Plane nb of neighbors"
                         command="SetLocalizationPlaneNbNeighbors"
                         number_of_elements="1"
                         default_values="5"
                         panel_visibility="advanced">
        <Documentation>
          Number of plane neighbors to extract to approximate the corresponding
          plane model.

          At least 3 points are needed to build a valid plane model.
          If below, plane models won't be usable and will be ignored.
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty name="Plane PCA factor 1"
                            command="SetLocalizationPlanePcaFactor1"
                            number_of_elements="1"
                            default_values="35."
                            panel_visibility="advanced">
        <Documentation>
          To check the plane neighborhood shape, the PCA eigenvalues must respect:

          *EigenValue1 >= Factor1 x EigenValue0*

          *Factor2 x EigenValue1 >= EigenValue2*

          with *EigenValue2 >= EigenValue1 >= EigenValue0*
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Plane PCA factor 2"
                            command="SetLocalizationPlanePcaFactor2"
                            number_of_elements="1"
                            default_values="8."
                            panel_visibility="advanced">
        <Documentation>
          To check the plane neighborhood shape, the PCA eigenvalues must respect:

          *EigenValue1 >= Factor1 x EigenValue0*

          *Factor2 x EigenValue1 >= EigenValue2*

          with *EigenValue2 >= EigenValue1 >= EigenValue0*
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Plane max model error"
                            command="SetLocalizationPlaneMaxModelError"
                            number_of_elements="1"
                            default_values="0.2"
                            panel_visibility="advanced">
        <Documentation>
          Max RMSE allowed between neighborhood and its fitted plane model to
          keep only accurate models
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty name="Blob nb of neighbors"
                         command="SetLocalizationBlobNbNeighbors"
                         number_of_elements="1"
                         default_values="10"
                         panel_visibility="advanced">
        <Documentation>
          Number of blob neighbors to extract to approximate the corresponding
          ellipsoid model.

          At least 4 points are needed to build a valid blob model.
          If below, blob models won't be usable and will be ignored.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" property="Use blobs" value="1" />
        </Hints>
      </IntVectorProperty>

      <DoubleVectorProperty name="Init saturation distance"
                            command="SetLocalizationInitSaturationDistance"
                            number_of_elements="1"
                            default_values="2."
                            panel_visibility="advanced">
        <Documentation>
          Maximum distance (in meters) beyond which the residual errors are
          saturated to robustify the optimization against outlier constraints.
          The residuals will be robustified by Tukey loss (50% of saturation at
          *SaturationDistance/2*, fully saturated at *SaturationDistance*).

          The saturation distance at each iteration is linearly interpolated
          between *Init* and *Final* saturation distance parameters.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Final saturation distance"
                            command="SetLocalizationFinalSaturationDistance"
                            number_of_elements="1"
                            default_values="0.5"
                            panel_visibility="advanced">
        <Documentation>
          Maximum distance (in meters) beyond which the residual errors are
          saturated to robustify the optimization against outlier constraints.
          The residuals will be robustified by Tukey loss (50% of saturation at
          *SaturationDistance/2*, fully saturated at *SaturationDistance*).

          The saturation distance at each iteration is linearly interpolated
          between *Init* and *Final* saturation distance parameters.
        </Documentation>
      </DoubleVectorProperty>

      <PropertyGroup label="Localization ICP matching and optimization parameters">
        <Property name="Wheel odometry weight" />
        <Property name="IMU gravity weight" />
        <Property name="ICP-Optimization iterations" />
        <Property name="LM optimization iterations" />
        <Property name="Max neighbors distance" />
        <Property name="Edge nb of neighbors" />
        <Property name="Edge nb min filtered neighbors" />
        <Property name="Edge PCA factor" />
        <Property name="Edge max model error" />
        <Property name="Plane nb of neighbors" />
        <Property name="Plane PCA factor 1" />
        <Property name="Plane PCA factor 2" />
        <Property name="Plane max model error" />
        <Property name="Blob nb of neighbors" />
        <Property name="Init saturation distance" />
        <Property name="Final saturation distance" />
      </PropertyGroup>

      <!-- ======================== Map Parameters ========================= -->

      <DoubleVectorProperty name="Keyframe distance threshold"
                            command="SetKfDistanceThreshold"
                            number_of_elements="1"
                            default_values="0.5"
                            panel_visibility="advanced">
        <Documentation>
          Minimum distance to travel since last keyframe to add a new one.
          Only keyframes' points are added to the map.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Keyframe angle threshold"
                            command="SetKfAngleThreshold"
                            number_of_elements="1"
                            default_values="5."
                            panel_visibility="advanced">
        <Documentation>
          Minimum angle (in degrees) to rotate since last keyframe to add a new one.
          Only keyframes' points are added to the map.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Edges map resolution"
                            command="SetVoxelGridLeafSizeEdges"
                            number_of_elements="1"
                            default_values="0.3"
                            panel_visibility="advanced">
        <Documentation>
          Minimum size of a leaf when downsampling the edges map using
          a voxel grid filter. It should not be too big or some high
          frequency geometric information will be lost. It should not
          be too low or the geometric information will be too local and
          computation time may increase.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Planes map resolution"
                            command="SetVoxelGridLeafSizePlanes"
                            number_of_elements="1"
                            default_values="0.6"
                            panel_visibility="advanced">
        <Documentation>
          Minimum size of a leaf when downsampling the planes map using
          a voxel grid filter. It should not be too big or some high
          frequency geometric information will be lost. It should not
          be too low or the geometric information will be too local and
          computation time may increase.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Blobs map resolution"
                            command="SetVoxelGridLeafSizeBlobs"
                            number_of_elements="1"
                            default_values="0.3"
                            panel_visibility="advanced">
        <Documentation>
          Minimum size of a leaf when downsampling the blobs map using
          a voxel grid filter. It should not be too big or some high
          frequency geometric information will be lost. It should not
          be too low or the geometric information will be too local and
          computation time may increase.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" property="Use blobs" value="1" />
        </Hints>
      </DoubleVectorProperty>

      <IntVectorProperty name="Rolling grid dimension"
                         command="SetVoxelGridSize"
                         number_of_elements="1"
                         default_values="50"
                         panel_visibility="advanced">
        <Documentation>
          Number of voxels in each direction of the rolling grid. It should be
          large enough to store a local map around current pose, but a too high
          value largely increase memory consumption.

          Each map is a *Rolling Grid*, storing points in a local outer cube of
          size *number of voxels x voxel resolution* meters. When a point should
          be added in the map but lies outside this outer cube, the whole map is
          rolled towards this point in order to save it, forgetting previous
          voxels in the opposite direction.
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty name="Rolling grid resolution"
                            command="SetVoxelGridResolution"
                            number_of_elements="1"
                            default_values="10."
                            panel_visibility="advanced">
        <Documentation>
          Resolution of a voxel of the rolling grid (meters per voxel).
          It should not be too big or too much points will be considered when
          trying to match the frame at the current position.
          This does not impact accuracy but only speed.
        </Documentation>
      </DoubleVectorProperty>

      <PropertyGroup label="Map parameters">
        <Property name="Keyframe distance threshold" />
        <Property name="Keyframe angle threshold" />
        <Property name="Edges map resolution" />
        <Property name="Planes map resolution" />
        <Property name="Blobs map resolution" />
        <Property name="Rolling grid dimension" />
        <Property name="Rolling grid resolution" />
      </PropertyGroup>

      <!-- ================ Confidence estimator parameters ================ -->

      <DoubleVectorProperty name="Overlap sampling ratio"
                            command="SetOverlapSamplingRatio"
                            number_of_elements="1"
                            default_values="0.25"
                            panel_visibility="advanced">
        <Documentation>
          Ratio of points (between 0 and 1) from the current frame to compute
          overlap on.

          The overlap estimates how much the current scan is well registered on
          the current maps.

          Downsampling accelerates the overlap computation, but may be less
          precise. A ratio of 1 uses all points, 0.5 uses 1 point over 2, etc.,
          0 disables overlap computation.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" property="Advanced return mode" value="1" />
        </Hints>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Velocity limits"
                            command="SetVelocityLimits"
                            number_of_elements="2"
                            default_values="1e6 1e6"
                            panel_visibility="advanced">
        <Documentation>
          Velocity thresholds to evaluate and discard pose.

          translation speed: m/s

          rotation speed: Â°/s
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" property="Advanced return mode" value="1" />
        </Hints>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Acceleration limits"
                            command="SetAccelerationLimits"
                            number_of_elements="2"
                            default_values="1e3 1e3"
                            panel_visibility="advanced">
        <Documentation>
          Acceleration threshold to evaluate and discard pose.

          translation acceleration: m/s^2

          rotation acceleration: Â°/s^2
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" property="Advanced return mode" value="1" />
        </Hints>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Time window duration"
                            command="SetTimeWindowDuration"
                            number_of_elements="1"
                            default_values="0.5"
                            panel_visibility="advanced">
        <Documentation>
          Duration of the window on poses to estimate the velocity in seconds.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" property="Advanced return mode" value="1" />
        </Hints>
      </DoubleVectorProperty>

      <PropertyGroup label="Confidence estimator parameters">
        <Property name="Overlap sampling ratio" />
        <Property name="Velocity limits" />
        <Property name="Acceleration limits" />
        <Property name="Time window duration" />
      </PropertyGroup>

    </SourceProxy>
  </ProxyGroup>
  <!-- End Online Slam -->

  <!-- Begin Offline Slam -->
  <ProxyGroup name="filters">
    <SourceProxy name="SlamOffline"
                 class="vtkSlamManager"
                 label="SLAM (offline)"
                 base_proxygroup="filters"
                 base_proxyname="SlamOnline">

      <Documentation
        short_help="Performs offline processing SLAM on the Lidar sensor's pointclouds."
        long_help="Performs offline processing SLAM on the Lidar sensor's pointclouds.">
        The SLAM filter uses LiDAR sensor pointclouds to compute sensor's
        trajectory and build a map of the environment.

        The SLAM algorithm is composed of four sequential steps:

          - Sampling strategy: extract keypoints that provide strong geometric information

          - Ego-Motion: estimate sensor motion since last frame

          - Localization: compute current frame pose in map using estimated Ego-Motion

          - Map update : add current registered points in map

        This filter performs offline processing of all input frames without live display.
      </Documentation>

      <IntVectorProperty name="All frames"
                         command="SetAllFrames"
                         number_of_elements="1"
                         default_values="1">
        <BooleanDomain name="bool" />
        <Documentation>
          Process all frames of the recording.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="First frame"
                         command="SetFirstFrame"
                         number_of_elements="1"
                         default_values="0">
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator" mode="enabled_state" property="All frames" value="0" />
        </Hints>
        <Documentation>
          The first frame to process.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="Last frame"
                         command="SetLastFrame"
                         number_of_elements="1"
                         default_values="0">
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator" mode="enabled_state" property="All frames" value="0" />
        </Hints>
        <Documentation>
          The last frame to process.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="Step size"
                         command="SetStepSize"
                         number_of_elements="1"
                         default_values="1"
                         panel_visibility="advanced">
        <Documentation>
          Process one frame every StepSize frames (e.g. every (1) frame, every
          2 frames, every 3 frames, and so on).
          A step size of 1 means that all frames between the first and the last
          (included) will be used. This property can be useful to trade
          robustness (step size equal to 1) and accuracy for speed (step size
          greater than 1).
        </Documentation>
      </IntVectorProperty>

      <PropertyGroup label="Offline SLAM manager parameters">
        <Property name="All frames" />
        <Property name="First frame" />
        <Property name="Last frame" />
        <Property name="Step size" />
      </PropertyGroup>

    </SourceProxy>
  </ProxyGroup>
  <!-- End Offline Slam -->

  <!-- Begin KeyPointsExtractor -->
  <ProxyGroup name="KeyPointsExtractors">
    <Proxy name="SpinningSensorKeypointExtractor"
           class="vtkSpinningSensorKeypointExtractor"
           label="Spinning Sensor Keypoint Extractor">

      <Documentation
        short_help="Extract keypoints from a spinning LiDAR sensor pointcloud."
        long_help="Extract edges, planes and blobs keypoints from a spinning LiDAR sensor pointcloud.">
        Extract edges, planes and blobs keypoints from a spinning LiDAR sensor pointcloud.
      </Documentation>

      <IntVectorProperty name="Neighborhood width"
                         command="SetNeighborWidth"
                         number_of_elements="1"
                         default_values="4"
                         panel_visibility="advanced">
        <Documentation>
          Number of neighbors to use on each side of current point to estimate
          the keypoints scores (curvature, planarity, depth gap, ...) in each
          scan line.
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty name="Min distance to sensor"
                            command="SetMinDistanceToSensor"
                            number_of_elements="1"
                            default_values="3."
                            panel_visibility="advanced">
        <Documentation>
          Minimum distance between a point and the sensor to be processed for
          the keypoint extraction. In other words, all points too close from the
          sensor are automatically rejected.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Min laser beam to surface angle"
                            command="SetMinBeamSurfaceAngle"
                            number_of_elements="1"
                            default_values="10."
                            panel_visibility="advanced">
        <Documentation>
          Minimum angle between the laser beam and the surface on which
          a point is laying to consider it as a potential keypoint.
          In other words, all points laying on too oblique surfaces
          relatively to the sensor are automatically rejected.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Plane max sinus angle"
                            command="SetPlaneSinAngleThreshold"
                            number_of_elements="1"
                            default_values="0.5"
                            panel_visibility="advanced">
        <Documentation>
          One strategy to consider a point as a planar keypoint is to compute
          the angle between the two lines that fit its previous and next neighborhoods.
          If the angle is close enough to 0Â° or 180Â° (sin(Angle) low enough), we consider
          the point as a planar keypoint.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Edge min sinus angle"
                            command="SetEdgeSinAngleThreshold"
                            number_of_elements="1"
                            default_values="0.86"
                            panel_visibility="advanced">
        <Documentation>
          One strategy to consider a point as an edge keypoint is to compute
          the angle between the two lines that fit its previous and next neighborhoods.
          If the angle is close enough to 90Â° (sin(Angle) high enough), we consider
          the point as an edge keypoint.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Edge min saliency distance"
                            command="SetEdgeSaliencyThreshold"
                            number_of_elements="1"
                            default_values="1.5"
                            panel_visibility="advanced">
        <Documentation>
          One strategy to consider a point as an edge keypoint is to compute
          the depth gap between the point and its far background neighborhood.
          If the gap is big enough, we consider the point as an edge keypoint.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Edge min intensity gap"
                            command="SetEdgeIntensityGapThreshold"
                            number_of_elements="1"
                            default_values="50."
                            panel_visibility="advanced">
        <Documentation>
          One strategy to consider a point as an edge keypoint is to compute
          the intensity gap between the point and its left and right neighbors.
          If the gap is big enough, we consider the point as an edge keypoint.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Edge min depth gap"
                            command="SetEdgeDepthGapThreshold"
                            number_of_elements="1"
                            default_values="0.15"
                            panel_visibility="advanced">
        <Documentation>
          One strategy to consider a point as an edge keypoint is to compute
          the gap between the point and its neighborhood, fitted by a line. Then
          we compute the distance between the point and the fitted lines. If the
          gap is big enough on at least one side, we consider the point as an
          edge keypoint.
        </Documentation>
      </DoubleVectorProperty>

      <PropertyGroup label="Spinning Sensor Keypoints Extractor parameters">
        <Property name="Neighborhood width" />
        <Property name="Min distance to sensor" />
        <Property name="Min laser beam to surface angle" />
        <Property name="Plane max sinus angle" />
        <Property name="Edge min sinus angle" />
        <Property name="Edge min saliency distance" />
        <Property name="Edge min intensity gap" />
        <Property name="Edge min depth gap" />
      </PropertyGroup>

    </Proxy>
  </ProxyGroup>
  <!-- End KeyPointsExtractors -->

</ServerManagerConfiguration>